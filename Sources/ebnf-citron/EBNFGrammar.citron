%class_name EBNFParser

%preface {
  import CitronParserModule
  import CitronLexerModule

  extension _CitronParserUnexpectedTokenError
    : CustomDebugStringConvertible
  {
    public var debugDescription: String {
      "UnexpectedToken(token: \(token), tokenCode: \(tokenCode))"
    }
  }
}

%default_nonterminal_type Any
// %nonterminal_type grammar {EBNF.RuleList}
// %nonterminal_type rule_list {EBNF.RuleList}
// %nonterminal_type rule {EBNF.Rule}
// %nonterminal_type alt_list {EBNF.AltList}
// %nonterminal_type alt {EBNF.Alt}
// %nonterminal_type term_list {EBNF.TermList}
// %nonterminal_type term {EBNF.Term}

%start_symbol grammar

%token UNRECOGNIZED_CHARACTER.
%token_type Token

%preface {
  import CitronParserModule
}

%left_associative OR.
%left_associative STAR PLUS QUESTION.
%right_associative IS_DEFINED_AS.

grammar ::= rule(l). {[l]}

rule ::= LHS(l) IS_DEFINED_AS alt_list(r). { (lhs: l, rhs: r)}

alt_list ::= alt(a). {[a]}
alt_list ::= alt_list(l) OR alt(r). { (l, r)}

alt ::= term_list(t). {t}
alt ::= . {[]}
term_list ::= term(t). {[t]}
term_list ::= term_list(l) term(r). {(l, r)}
term ::= LPAREN alt_list(g) RPAREN. {g}
term ::= SYMBOL(s). {s}
term ::= LITERAL(l). {
  (
     l.text.dropFirst().dropLast().split(separator: "\\").joined(), 
     position: l.position)
}

%token_set quantifier STAR PLUS QUESTION.
term ::= term(t) quantifier(q). {
  (t, q.text.first!, position: SourceRegion.empty)
}
